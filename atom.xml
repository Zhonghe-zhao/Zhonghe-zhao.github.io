<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zhonghe_Zhao</title>
  
  
  <link href="https://whuichenggong.github.io/atom.xml" rel="self"/>
  
  <link href="https://whuichenggong.github.io/"/>
  <updated>2025-05-11T07:12:22.734Z</updated>
  <id>https://whuichenggong.github.io/</id>
  
  <author>
    <name>赵忠赫</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>函数指针数组</title>
    <link href="https://whuichenggong.github.io/2025/04/01/go/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
    <id>https://whuichenggong.github.io/2025/04/01/go/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</id>
    <published>2025-04-01T13:21:47.328Z</published>
    <updated>2025-05-11T07:12:22.734Z</updated>
    
    <content type="html"><![CDATA[<p>引用博文；</p><p>(博客园)[<a href="https://www.cnblogs.com/tp-16b/p/7860491.html]">https://www.cnblogs.com/tp-16b/p/7860491.html]</a></p><p>对于在xv6中看到的一个映射表关系</p><p>关于： 函数指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">[SYS_kill]    sys_kill,</span><br><span class="line">[SYS_exec]    sys_exec,</span><br><span class="line">[SYS_fstat]   sys_fstat,</span><br><span class="line">[SYS_chdir]   sys_chdir,</span><br><span class="line">[SYS_dup]     sys_dup,</span><br><span class="line">[SYS_getpid]  sys_getpid,</span><br><span class="line">[SYS_sbrk]    sys_sbrk,</span><br><span class="line">[SYS_sleep]   sys_sleep,</span><br><span class="line">[SYS_uptime]  sys_uptime,</span><br><span class="line">[SYS_open]    sys_open,</span><br><span class="line">[SYS_write]   sys_write,</span><br><span class="line">[SYS_mknod]   sys_mknod,</span><br><span class="line">[SYS_unlink]  sys_unlink,</span><br><span class="line">[SYS_link]    sys_link,</span><br><span class="line">[SYS_mkdir]   sys_mkdir,</span><br><span class="line">[SYS_close]   sys_close,</span><br><span class="line">[SYS_trace]   sys_trace,</span><br><span class="line">[SYS_sysinfo] sys_sysinfo,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数组和指针是没关系的！</p><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>int (*p)[4];     </p><p>char (*p)[4]; </p><h4 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h4><p>int *p[10]; </p><p>char *p[10];    </p><p>char **p[10] </p><p>它们都是大小为10元素的数组，里面分别存放着元素为 int<em>，char</em>, char** 类型的指针数组</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里定义void (*p)()。一眼可知pfun1先和*结合，说明pfun1是指针，指针指向的是一个函数，指向的函数无参数，返回值类型为void。</span><br></pre></td></tr></table></figure><p>这里定义void (<em>p)()。一眼可知pfun1先和</em>结合，说明pfun1是指针，指针指向的是一个函数，指向的函数无参数，返回值类型为void。</p><h4 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h4><p>把函数的地址存到一个数组中，那这个数组就叫函数指针数组</p><p>int (*parr1[10])();</p><p>int *parr2<a href="">10</a>;</p><p>int (*)() parr3[10]; </p><p>parr1 先和 [] 结合，说明parr1是数组，数组的内容是什么呢？ 是 int (*)() 类型的函数指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;引用博文；&lt;/p&gt;
&lt;p&gt;(博客园)[&lt;a href=&quot;https://www.cnblogs.com/tp-16b/p/7860491.html]&quot;&gt;https://www.cnblogs.com/tp-16b/p/7860491.html]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于在</summary>
      
    
    
    
    <category term="go" scheme="https://whuichenggong.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>总结一下最近</title>
    <link href="https://whuichenggong.github.io/2025/03/31/%E7%94%9F%E6%B4%BB/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91/"/>
    <id>https://whuichenggong.github.io/2025/03/31/%E7%94%9F%E6%B4%BB/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8B%E6%9C%80%E8%BF%91/</id>
    <published>2025-03-31T13:24:00.757Z</published>
    <updated>2025-05-11T07:15:01.704Z</updated>
    
    <content type="html"><![CDATA[<p>好久没有更新博客了，因为一些重要的笔记都移动到Obsidian上面写了，很方便 ，谈谈新的一年对于技术的追求</p><p>在大二上学期以及在大一的时候都觉得计算机基础是非常重要的，因为一些声音吧，也沉迷于如何快速做项目啊，背八股文啊，越来越觉得空虚<br>没有得到什么，在大一的时候天真的以为只要学会一门语言就可以很强哈哈哈哈，<br>到现在再看,语言真的只是一门工具，在想学习什么的时候，顺带学一下就可以研究自己更喜欢的领域，<br>在本学期，我的思想发生了重大的转变，其实本来也是，我觉得要想学习计算机，你如果不去理解计算机那么算的上什么学习计算机呢？<br>数据结构为什么重要？世界本来就是一个巨大的存储系统，如何存储数据？如何快速的存储数据是那么的重要!<br>我们用的数据库，操作系统，不全都是数据结构和算法的功劳吗？学习计算机的乐趣对于我来说<br>为什么跨越千里可以和对方聊天，每天坐在电脑前，为什么电脑可以这么工作，这就是一个黑盒，需要我们慢慢去挖掘，就是挖掘他们背后的黑盒，真的使我感到开心<br>就像文杰老哥说的一样 在这个ai的时候上层应用的逻辑显得没有那么重要。</p><p>在学习中一定要结合实际，才能深刻的理解这些知识，也就是所谓的八股文，发自内心的去理解，现在才理解什么是带着问题去读书去看，那种带入疑问去阅读，最终<br>疑问被解决的感觉是很爽的！</p><p>没有走过的路，听了别人和你说那是一条做错的路，你可能不信，只有你真正体验到了才知道那到底是一条什么路，即使最终的结果不尽人意，但是过程才是最重要的<br>对于结果呢？哈哈哈留下思考 过程与结果！可能每个人的看法也会不同吧，人都是生下来走一遭，自己的路一定要自己选自己走！那才是你的意义，别人会给你参考<br>会给你建议，最终的路都是自己走出来的！ 也感谢我遇见的所有人！</p><p>也希望自己能够坚持自己吧！ </p><ul><li>Trust but Verify</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久没有更新博客了，因为一些重要的笔记都移动到Obsidian上面写了，很方便 ，谈谈新的一年对于技术的追求&lt;/p&gt;
&lt;p&gt;在大二上学期以及在大一的时候都觉得计算机基础是非常重要的，因为一些声音吧，也沉迷于如何快速做项目啊，背八股文啊，越来越觉得空虚&lt;br&gt;没有得到什么，在</summary>
      
    
    
    
    <category term="生活" scheme="https://whuichenggong.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>在这个时代，你是否过度依赖ai</title>
    <link href="https://whuichenggong.github.io/2025/02/12/%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/%E6%98%AF%E5%90%A6%E8%BF%87%E5%BA%A6%E4%BE%9D%E8%B5%96ai/"/>
    <id>https://whuichenggong.github.io/2025/02/12/%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/%E6%98%AF%E5%90%A6%E8%BF%87%E5%BA%A6%E4%BE%9D%E8%B5%96ai/</id>
    <published>2025-02-12T10:04:53.120Z</published>
    <updated>2025-05-11T07:14:37.165Z</updated>
    
    <content type="html"><![CDATA[<p>越来越觉得做任何事都离开不了ai，任何报错只需要复制粘贴，原本看文档可以解决的错误，让ai可能很长时间，都无法解决，那种来回粘贴的感觉<br>让我停止了思考，不想动脑，我好像成为了ai和代码之间的桥梁，ai让我在编码中也变得懒惰，那种空虚是真的！</p><p>这种急性子，渴望答案快速出来的懒惰，必须要改了！</p><ol><li>自己看懂错误出在哪里</li><li>查阅文档，试着自己解决</li><li>做事之前，自己构思</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;越来越觉得做任何事都离开不了ai，任何报错只需要复制粘贴，原本看文档可以解决的错误，让ai可能很长时间，都无法解决，那种来回粘贴的感觉&lt;br&gt;让我停止了思考，不想动脑，我好像成为了ai和代码之间的桥梁，ai让我在编码中也变得懒惰，那种空虚是真的！&lt;/p&gt;
&lt;p&gt;这种急性子，</summary>
      
    
    
    
    <category term="文章分享" scheme="https://whuichenggong.github.io/categories/%E6%96%87%E7%AB%A0%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>系统思考</title>
    <link href="https://whuichenggong.github.io/2025/01/30/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/"/>
    <id>https://whuichenggong.github.io/2025/01/30/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/%E7%B3%BB%E7%BB%9F%E6%80%9D%E8%80%83/</id>
    <published>2025-01-30T01:48:25.183Z</published>
    <updated>2025-05-11T07:20:03.589Z</updated>
    
    <content type="html"><![CDATA[<p>各个实体之间的联系构成了系统，当你在研究一个系统的时候，如果你切分了其中某一部分拿出来研究<br>必定会切断，这部分与整体的联系，也就是破坏了整个系统！</p><h1 id="必须从整体式理解一个系统"><a href="#必须从整体式理解一个系统" class="headerlink" title="必须从整体式理解一个系统"></a>必须从整体式理解一个系统</h1><p>关于组件的知识对于整体上理解一个系统，作用非常有限，在某些情况下，这些知识甚至具有相反的效果</p><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><ol><li><p>组件知识是局部的，而系统理解需要全局视角</p></li><li><p>组件是系统的一部分，但系统的行为不仅仅是组件的总和，还涉及它们之间的交互、架构模式、数据流、依赖关系等。<br>只关注组件，容易忽略系统级别的设计，比如如何扩展、如何容错、如何保障一致性。<br>局部最优 ≠ 全局最优</p></li><li><p>过度关注组件实现，可能会优化某个组件的性能或功能，但不一定符合整个系统的最佳实践。<br>例如，一个高效的缓存组件如果没有考虑分布式一致性，可能会导致整个系统数据不一致。<br>局部思维可能会误导系统设计</p></li><li><p>过分依赖某个组件，可能导致架构决策受限，比如：<br>认为数据库事务可以解决所有一致性问题，而忽略了分布式事务的挑战。<br>认为某个微服务框架很强大，而忽略了微服务本身的复杂性（如治理、监控等）。</p></li></ol><hr><p>关键是要有“系统思维”，知道什么时候关注细节，什么时候抬头看全局</p><p>系统展示出来的特性是做作为一个整体所拥有的特性，而不是任何一个部件所拥有的特性</p><h1 id="自组织"><a href="#自组织" class="headerlink" title="自组织"></a>自组织</h1><p>保持高度有序状态，具有能量流，</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;各个实体之间的联系构成了系统，当你在研究一个系统的时候，如果你切分了其中某一部分拿出来研究&lt;br&gt;必定会切断，这部分与整体的联系，也就是破坏了整个系统！&lt;/p&gt;
&lt;h1 id=&quot;必须从整体式理解一个系统&quot;&gt;&lt;a href=&quot;#必须从整体式理解一个系统&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="书后心得" scheme="https://whuichenggong.github.io/categories/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>新年新气象</title>
    <link href="https://whuichenggong.github.io/2025/01/28/%E7%94%9F%E6%B4%BB/%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>https://whuichenggong.github.io/2025/01/28/%E7%94%9F%E6%B4%BB/%E6%96%B0%E7%9A%84%E4%B8%80%E5%B9%B4/</id>
    <published>2025-01-28T14:42:05.561Z</published>
    <updated>2025-01-28T14:43:49.910Z</updated>
    
    <content type="html"><![CDATA[<p>辞旧迎新，改变最大的一年！</p><p>新的一年开始了，我希望我能在新的一年里，不断的审视自己，关注自己的一言一行，一举一动，如果有哪些坏习惯，要去更改！</p><p>希望自己变得越来越好吧！ 顺其自然的去做自己该去做的事，没有目的地！</p><p>Passion never fails！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;辞旧迎新，改变最大的一年！&lt;/p&gt;
&lt;p&gt;新的一年开始了，我希望我能在新的一年里，不断的审视自己，关注自己的一言一行，一举一动，如果有哪些坏习惯，要去更改！&lt;/p&gt;
&lt;p&gt;希望自己变得越来越好吧！ 顺其自然的去做自己该去做的事，没有目的地！&lt;/p&gt;
&lt;p&gt;Passion n</summary>
      
    
    
    
    <category term="生活" scheme="https://whuichenggong.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>I/O多路复用中的一些疑惑</title>
    <link href="https://whuichenggong.github.io/2025/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://whuichenggong.github.io/2025/01/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</id>
    <published>2025-01-23T04:26:36.180Z</published>
    <updated>2025-05-11T07:15:33.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h1><p>I&#x2F;O多路复用如何实现？<br>这里面用到了什么数据结构吗？<br>如果A先发起了请求在等待中然后去处理B的请求，当A的请求到达后，并处理完成后，还会继续处理B的请求吗？<br>还有在后续处理A的过程中，B处在等待的过程中，有可能其他的服务去处理B吗？<br>B在发送请求到A后，它在等待的过程中还会发送请求吗？</p><h1 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h1><p>1<strong>如果 A 请求发起了并在等待中，处理 B 的请求后，A 的请求完成后，还会继续处理 B 吗？</strong></p><p><strong>A</strong> 的请求和 <strong>B</strong> 的请求是两个独立的 I&#x2F;O 操作。当 A 的请求进入等待状态后（比如等待数据库查询或等待网络响应），服务器会继续处理 B 的请求，甚至是 C、D 等其他请求。</p><ul><li><strong>当 A 的请求到达后</strong>，服务器会接到通知，处理 <strong>A</strong> 的请求。</li><li><strong>在处理 A 请求时</strong>，如果 B 的请求仍然在等待状态，那么此时 B 并不会被继续处理，除非 B 的请求也准备好了。</li><li>处理完成 A 的请求后，服务器会继续处理下一个在等待队列中有数据准备好的请求（比如 B 的请求，如果它的数据已经准备好了）。</li></ul><p>可以理解为 <strong>事件驱动</strong>，服务器并不会直接按顺序处理 A、B 请求，而是看哪个请求的 I&#x2F;O 操作准备好了，哪个就被处理。</p><p>2<strong>在后续处理 A 的过程中，B 在等待时，是否有可能其他服务去处理 B？</strong></p><p><strong>B 的请求</strong>一般会在服务器端的同一线程中等待，除非采取了 <strong>分布式架构</strong> 或 <strong>负载均衡</strong>，否则通常不会有其他服务去处理 B。B 依然在等待队列中，直到 I&#x2F;O 多路复用机制通知服务器有数据准备好，才会继续处理。</p><p>但是，在分布式场景下，B 的请求有可能会被路由到 <strong>其他节点</strong> 或 <strong>服务实例</strong> 去处理。例如，微服务架构中，某个请求可能会被负载均衡到另一个服务实例处理。</p><p>3<strong>B 在发送请求到 A 后，它在等待的过程中是否会发送请求？</strong></p><p>是的，<strong>B</strong> 可以继续发送请求到 <strong>其他服务</strong>。I&#x2F;O 多路复用的特点是 <strong>非阻塞</strong>，也就是说，B 在等待 A 的响应时，它可以继续进行其他 I&#x2F;O 操作，甚至发送新的请求到其他服务。</p><p>例如：</p><ul><li><strong>B</strong> 在等待 A 的响应时，可能会继续向其他服务发起请求。</li><li><strong>B</strong> 可以处理自己的其他任务，或继续等待其他 I&#x2F;O 操作。</li></ul><p>这种 <strong>并发</strong> 和 <strong>非阻塞</strong> 的机制让多个请求可以并行进行，而每个请求不会阻塞其他请求的进程。</p><h1 id="如何应用多路复用到实际生活中？"><a href="#如何应用多路复用到实际生活中？" class="headerlink" title="如何应用多路复用到实际生活中？"></a>如何应用多路复用到实际生活中？</h1><p>虽然多路复用技术本身是一个操作系统层面的技术，但它的应用对于 高并发处理 和 性能优化 是至关重要的，在多个实际生活场景中都有体现：</p><ol><li>网络服务：<br>Web 服务器：当一个 Web 服务器需要同时处理多个客户端请求时，使用多路复用可以有效避免为每个请求创建一个线程的高昂开销。比如，现代 Web 服务器（如 Nginx）使用多路复用来管理大量的 HTTP 请求。<br>数据库连接池：当多个客户端请求数据库时，连接池可以通过多路复用来共享连接池中的数据库连接，避免每个请求都创建新的连接。</li><li>实时通信应用：<br>即时消息（IM）系统：例如，聊天应用的服务器需要同时处理大量用户的消息，使用多路复用技术可以提高服务器处理并发连接的效率。<br>视频流服务：如直播平台需要同时处理大量用户的请求，多路复用技术可以有效管理所有用户的连接，确保数据流的稳定性。</li><li>操作系统中的 I&#x2F;O 管理：<br>操作系统内核在管理文件系统和网络连接时，也会使用多路复用来提高磁盘和网络 I&#x2F;O 操作的效率。例如，Linux 内核的 epoll 就是在处理大规模的网络连接时非常高效的技术。<br>硬件资源管理：<br>设备管理：例如，在一些嵌入式系统中，多个硬件设备可能需要同时进行数据读写，操作系统可以通过多路复用的方式将数据的读写操作交给不同的设备驱动程序处理。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;疑问：&quot;&gt;&lt;a href=&quot;#疑问：&quot; class=&quot;headerlink&quot; title=&quot;疑问：&quot;&gt;&lt;/a&gt;疑问：&lt;/h1&gt;&lt;p&gt;I&amp;#x2F;O多路复用如何实现？&lt;br&gt;这里面用到了什么数据结构吗？&lt;br&gt;如果A先发起了请求在等待中然后去处理B的请求，当A的请</summary>
      
    
    
    
    <category term="计算机系统" scheme="https://whuichenggong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Go中[]byte转换io.Reader</title>
    <link href="https://whuichenggong.github.io/2025/01/21/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/[]byte_io.Reader/"/>
    <id>https://whuichenggong.github.io/2025/01/21/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/[]byte_io.Reader/</id>
    <published>2025-01-21T09:45:01.909Z</published>
    <updated>2025-05-11T07:13:39.944Z</updated>
    
    <content type="html"><![CDATA[<p>[]byte 转 io.Reader</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">byte</span>(<span class="string">&quot;Hello AlwaysBeta&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// byte slice to bytes.Reader, which implements the io.Reader interface</span></span><br><span class="line">    reader := bytes.NewReader(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the data from reader</span></span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(data))</span><br><span class="line">    <span class="keyword">if</span> _, err := reader.Read(buf); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="type">string</span>(buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.Reader 转 []byte</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ioReaderData := strings.NewReader(<span class="string">&quot;Hello AlwaysBeta&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// creates a bytes.Buffer and read from io.Reader</span></span><br><span class="line">    buf := &amp;bytes.Buffer&#123;&#125;</span><br><span class="line">    buf.ReadFrom(ioReaderData)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retrieve a byte slice from bytes.Buffer</span></span><br><span class="line">    data := buf.Bytes()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only read the left bytes from 6</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(data[<span class="number">6</span>:]))</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Buffer 暂存空间，并将一个字符串写入 Buffer</span></span><br><span class="line">    <span class="comment">// 使用 io.Writer 的 Write 方法写入</span></span><br><span class="line">    <span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">    buf.Write([]<span class="type">byte</span>(<span class="string">&quot;hello world , &quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 Fprintf 将一个字符串拼接到 Buffer 里</span></span><br><span class="line">    fmt.Fprintf(&amp;buf, <span class="string">&quot; welcome to golang !&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Buffer 的内容输出到标准输出设备</span></span><br><span class="line">    buf.WriteTo(os.Stdout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>o.Reader 接口：io.Reader 接口要求实现 Read(p []byte) (n int, err error) 方法，返回读取的字节数和错误信息。*bytes.Reader 就是通过实现这个方法来允许对 []byte 进行按块读取。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[]byte 转 io.Reader&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    <category term="技术分享" scheme="https://whuichenggong.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>避免在Go中使用 io.ReadAll</title>
    <link href="https://whuichenggong.github.io/2025/01/21/go/Go_ReadAll/"/>
    <id>https://whuichenggong.github.io/2025/01/21/go/Go_ReadAll/</id>
    <published>2025-01-21T06:52:21.288Z</published>
    <updated>2025-05-11T07:20:03.592Z</updated>
    
    <content type="html"><![CDATA[<p>io.ReadAll 主要的作用是从一个 io.Reader 中读取所有数据，直到结尾。</p><p><strong>虽然使用方便：</strong></p><p><strong>两个明显的缺点：</strong></p><p>遇到大文件时，这个函数就会暴露出</p><p>性能问题，文件越大，性能越差。</p><p>文件过大的话，可能直接撑爆内存，导致程序崩溃。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    res, err := http.Get(<span class="string">&quot;http://www.google.com/robots.txt&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    robots, err := io.ReadAll(res.Body)</span><br><span class="line">    res.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%s&quot;</span>, robots)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>io.ReadAll 的源码如下：</p><p>&#x2F;&#x2F; src&#x2F;io&#x2F;io.go<br>func ReadAll(r Reader) ([]byte, error) {<br>b :&#x3D; make([]byte, 0, 512)<br>for {<br>n, err :&#x3D; r.Read(b[len(b):cap(b)])<br>b &#x3D; b[:len(b)+n]<br>if err !&#x3D; nil {<br>if err &#x3D;&#x3D; EOF {<br>err &#x3D; nil<br>}<br>return b, err<br>}<br>        if len(b) &#x3D;&#x3D; cap(b) {<br>            &#x2F;&#x2F; Add more capacity (let append pick how much).<br>            b &#x3D; append(b, 0)[:len(b)]<br>        }<br>    }<br>}</p><p>创建一个 512 字节的 buf；</p><p>不断读取内容到 buf，当 buf 满的时候，会追加一个元素，促使其重新分配内存；</p><p>直到结尾或报错，则返回；</p><h4 id="了解-Go-切片的扩容策略，如下："><a href="#了解-Go-切片的扩容策略，如下：" class="headerlink" title="了解 Go 切片的扩容策略，如下："></a>了解 Go 切片的扩容策略，如下：</h4><p>如果期望容量大于当前容量的两倍就会使用期望容量；</p><p>如果当前切片的长度小于 1024 就会将容量翻倍；</p><p>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，直到新容量大于期望容量；</p><h4 id="替换方案："><a href="#替换方案：" class="headerlink" title="替换方案："></a>替换方案：</h4><p>可以使用 io.Copy 函数来代替，源码定义如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> copyBuffer(dst, src, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其功能是直接从 src 读取数据，并写入到 dst</p><p>和io.ReadAll 最大的不同就是没有把所有数据一次性都取出来，而是不断读取，不断写入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/io/io.go</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyBuffer</span><span class="params">(dst Writer, src Reader, buf []<span class="type">byte</span>)</span></span> (written <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果源实现了 WriteTo 方法，则直接调用 WriteTo</span></span><br><span class="line">    <span class="keyword">if</span> wt, ok := src.(WriterTo); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> wt.WriteTo(dst)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同样的，如果目标实现了 ReaderFrom 方法，则直接调用 ReaderFrom</span></span><br><span class="line">    <span class="keyword">if</span> rt, ok := dst.(ReaderFrom); ok &#123;</span><br><span class="line">        <span class="keyword">return</span> rt.ReadFrom(src)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 buf 为空，则创建 32KB 的 buf</span></span><br><span class="line">    <span class="keyword">if</span> buf == <span class="literal">nil</span> &#123;</span><br><span class="line">        size := <span class="number">32</span> * <span class="number">1024</span></span><br><span class="line">        <span class="keyword">if</span> l, ok := src.(*LimitedReader); ok &amp;&amp; <span class="type">int64</span>(size) &gt; l.N &#123;</span><br><span class="line">            <span class="keyword">if</span> l.N &lt; <span class="number">1</span> &#123;</span><br><span class="line">                size = <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                size = <span class="type">int</span>(l.N)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="built_in">make</span>([]<span class="type">byte</span>, size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环读取数据并写入</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        nr, er := src.Read(buf)</span><br><span class="line">        <span class="keyword">if</span> nr &gt; <span class="number">0</span> &#123;</span><br><span class="line">            nw, ew := dst.Write(buf[<span class="number">0</span>:nr])</span><br><span class="line">            <span class="keyword">if</span> nw &lt; <span class="number">0</span> || nr &lt; nw &#123;</span><br><span class="line">                nw = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> ew == <span class="literal">nil</span> &#123;</span><br><span class="line">                    ew = errInvalidWrite</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            written += <span class="type">int64</span>(nw)</span><br><span class="line">            <span class="keyword">if</span> ew != <span class="literal">nil</span> &#123;</span><br><span class="line">                err = ew</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> nr != nw &#123;</span><br><span class="line">                err = ErrShortWrite</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> er != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> er != EOF &#123;</span><br><span class="line">                err = er</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> written, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数执行步骤如下：</p><p>如果源实现了 WriteTo 方法，则直接调用 WriteTo 方法；</p><p>同样的，如果目标实现了 ReaderFrom 方法，则直接调用 ReaderFrom 方法；</p><p>如果 buf 为空，则创建 32KB 的 buf；</p><p>最后就是循环 Read 和 Write；</p><p>io.Copy 函数不会一次性读取全部数据，也不会频繁进行切片扩容，显然在数据量大时是更好的选择。</p><h4 id="最大区别："><a href="#最大区别：" class="headerlink" title="最大区别："></a>最大区别：</h4><p>逐块读取：io.Copy 是按需读取数据并写入目标流。每次读取一小块数据（通常是缓冲区大小），然后将它写入目标，处理完后立即丢弃这部分数据，不会将它们保持在内存中。</p><p>一次性读取：io.ReadAll 会从源读取数据并将整个内容一次性加载到内存中，然后返回一个 []byte 切片。这意味着它会一直读取直到数据流结束，所有数据都存储在一个大的内存区域中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;io.ReadAll 主要的作用是从一个 io.Reader 中读取所有数据，直到结尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然使用方便：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;两个明显的缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遇到大文件时，这个函数就会暴露出&lt;/p&gt;</summary>
      
    
    
    
    <category term="go" scheme="https://whuichenggong.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>Go语言的学习资料</title>
    <link href="https://whuichenggong.github.io/2025/01/15/go/Golang/"/>
    <id>https://whuichenggong.github.io/2025/01/15/go/Golang/</id>
    <published>2025-01-15T03:05:31.524Z</published>
    <updated>2025-05-11T07:20:03.542Z</updated>
    
    <content type="html"><![CDATA[<p>学习 Go 微服务开发的资料有很多，以下是一些推荐的资源，可以帮助你系统地掌握微服务相关的概念和实现方式：</p><h3 id="1-官方文档与教程"><a href="#1-官方文档与教程" class="headerlink" title="1. 官方文档与教程"></a>1. <strong>官方文档与教程</strong></h3><ul><li><p><strong>Go 官方文档</strong>：<a href="https://golang.org/doc/">Go Documentation</a><br>这是学习 Go 的基础，提供了完整的 Go 语言教程和标准库的文档。</p></li><li><p><strong>gRPC 官方文档</strong>：<a href="https://grpc.io/docs/languages/go/">gRPC Go</a><br>如果你计划在微服务中使用 gRPC 进行高效的远程过程调用，gRPC 的官方 Go 文档会非常有帮助。</p></li><li><p><strong>Go kit</strong>：<a href="https://gokit.io/">Go Kit Documentation</a><br>Go kit 是一个适合构建分布式系统的 Go 微服务框架，官方文档详细介绍了如何使用该框架构建健壮的微服务。</p></li><li><p><strong>Micro Framework</strong>：<a href="https://micro.mu/docs/">Micro Documentation</a><br>Micro 是一个现代化的微服务框架，支持服务发现、消息队列、RPC 通信等，适合快速构建微服务应用。</p></li></ul><h3 id="2-视频教程与在线课程"><a href="#2-视频教程与在线课程" class="headerlink" title="2. 视频教程与在线课程"></a>2. <strong>视频教程与在线课程</strong></h3><ul><li><strong>Pluralsight - Building Microservices with Go</strong><br><a href="https://www.pluralsight.com/courses/go-building-microservices">链接</a><br>这个课程介绍了如何使用 Go 构建可扩展和高效的微服务架构，包括通信机制、数据库、API 设计等。</li></ul><h3 id="3-书籍推荐"><a href="#3-书籍推荐" class="headerlink" title="3. 书籍推荐"></a>3. <strong>书籍推荐</strong></h3><ul><li><p><strong>《Go语言圣经》</strong>（The Go Programming Language）<br><a href="https://www.amazon.cn/dp/B085TK2XN9">链接</a><br>本书是学习 Go 语言的经典之作，虽然不专门讲解微服务，但它可以帮助你理解 Go 语言的基础和并发编程，为后续微服务开发打下坚实基础。</p></li><li><p><strong>《Go微服务开发》</strong>（Microservices with Go）<br><a href="https://www.amazon.cn/dp/B01N3NL6T2">链接</a><br>本书专注于 Go 在微服务中的应用，涵盖了服务发现、负载均衡、容器化等内容，非常适合想深入学习 Go 微服务架构的开发者。</p></li><li><p><strong>《Go Web编程》</strong>（Go Web Programming）<br><a href="https://www.amazon.cn/dp/B0849ZNB52">链接</a><br>这本书详细介绍了如何使用 Go 进行 Web 开发，包括构建 RESTful API 和与数据库交互等内容，是微服务开发的良好起点。</p></li></ul><h3 id="4-博客与社区"><a href="#4-博客与社区" class="headerlink" title="4. 博客与社区"></a>4. <strong>博客与社区</strong></h3><ul><li><p><strong>Go Micro Blog</strong>：<a href="https://www.micro.mu/blog/">Go Micro Blog</a><br>这个博客是 Micro 框架的官方网站，内容涵盖 Go 微服务框架的最佳实践、教程和案例，适合深入学习。</p></li><li><p><strong>Medium 上的 Go 微服务相关文章</strong><br><a href="https://medium.com/tag/microservices">Go Microservices</a><br>在 Medium 上有许多关于 Go 微服务的优秀文章，适合了解最新的开发趋势和实践。</p></li><li><p><strong>Go 语言中文社区</strong>：<a href="https://studygolang.com/">Go 语言中文网</a><br>这是一个专注于 Go 语言的中文社区，涵盖了大量关于 Go 语言及其应用的文章和讨论，其中也包括微服务相关的内容。</p></li></ul><h3 id="5-GitHub-项目与代码示例"><a href="#5-GitHub-项目与代码示例" class="headerlink" title="5. GitHub 项目与代码示例"></a>5. <strong>GitHub 项目与代码示例</strong></h3><ul><li><p><strong>Go 微服务项目示例</strong><br><a href="https://github.com/microservices-demo/microservices-demo">Go Microservices Example</a><br>这是一个完整的微服务示例项目，使用 Go 语言实现，涵盖了微服务中的常见功能，如服务注册、健康检查、API 网关等。</p></li><li><p><strong>Go Kit 示例项目</strong><br><a href="https://github.com/go-kit/kit">Go Kit Example</a><br>Go kit 官方 GitHub 仓库，包含多个示例，演示了如何使用 Go kit 框架构建微服务。</p></li><li><p><strong>gRPC Go 示例</strong><br><a href="https://github.com/grpc/grpc-go/tree/master/examples">gRPC Go Examples</a><br>这是 gRPC 官方的 Go 示例代码，适合需要使用 gRPC 进行微服务通信的开发者。</p></li></ul><p>通过这些资料，你可以从基础到进阶学习 Go 语言在微服务架构中的应用，不仅可以掌握微服务的基本概念和技术，还能了解如何使用 Go 构建健壮的微服务系统。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习 Go 微服务开发的资料有很多，以下是一些推荐的资源，可以帮助你系统地掌握微服务相关的概念和实现方式：&lt;/p&gt;
&lt;h3 id=&quot;1-官方文档与教程&quot;&gt;&lt;a href=&quot;#1-官方文档与教程&quot; class=&quot;headerlink&quot; title=&quot;1. 官方文档与教程&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="go" scheme="https://whuichenggong.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>青训营开始</title>
    <link href="https://whuichenggong.github.io/2025/01/14/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E9%9D%92%E8%AE%AD%E8%90%A5/"/>
    <id>https://whuichenggong.github.io/2025/01/14/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E9%9D%92%E8%AE%AD%E8%90%A5/</id>
    <published>2025-01-14T11:03:27.871Z</published>
    <updated>2025-05-11T07:14:05.890Z</updated>
    
    <content type="html"><![CDATA[<p>抖音商城：</p><p>简易抖音商城：</p><p>Postgres Go（Hertz Kitex Gorm GoRedis Eino）<br>（一）注册中心继承<br>注册中心集成（etcd Consull Nacos） 自动注册服务数据</p><p>（二）身份认证</p><ol><li>登录认证</li><li>权限认证（高级）</li></ol><p>(三) 可观测要求</p><ol><li>日志记录与监控</li></ol><p>(四) 可靠性要求</p><ol><li>容错机制</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;抖音商城：&lt;/p&gt;
&lt;p&gt;简易抖音商城：&lt;/p&gt;
&lt;p&gt;Postgres Go（Hertz Kitex Gorm GoRedis Eino）&lt;br&gt;（一）注册中心继承&lt;br&gt;注册中心集成（etcd Consull Nacos） 自动注册服务数据&lt;/p&gt;
&lt;p&gt;（二）身份认证</summary>
      
    
    
    
    <category term="技术分享" scheme="https://whuichenggong.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>Go工作池</title>
    <link href="https://whuichenggong.github.io/2025/01/14/backend/%E5%B9%B6%E5%8F%91%E8%B5%84%E6%BA%90/"/>
    <id>https://whuichenggong.github.io/2025/01/14/backend/%E5%B9%B6%E5%8F%91%E8%B5%84%E6%BA%90/</id>
    <published>2025-01-14T04:19:13.371Z</published>
    <updated>2025-05-11T07:11:39.541Z</updated>
    
    <content type="html"><![CDATA[<p>学习 Go 的工作池模式，你可以按照以下步骤系统掌握：</p><hr><h3 id="1-理解工作池模式的概念"><a href="#1-理解工作池模式的概念" class="headerlink" title="1. 理解工作池模式的概念"></a>1. <strong>理解工作池模式的概念</strong></h3><ul><li>工作池是一种常见的并发模式，通过限制并发任务的数量，提高资源利用率，避免系统过载。</li><li>核心思想：创建固定数量的工作者（Worker），从任务队列中取任务处理，直到任务完成。</li></ul><hr><h3 id="2-学习基础知识"><a href="#2-学习基础知识" class="headerlink" title="2. 学习基础知识"></a>2. <strong>学习基础知识</strong></h3><ul><li><strong>Goroutines</strong>：<br>学习如何使用 Go 的轻量级线程 <code>goroutines</code>。<ul><li><a href="https://go.dev/tour/concurrency/1">Go 官方文档 - Goroutines</a></li></ul></li><li><strong>Channels</strong>：<br>掌握 Go 的 <code>channels</code> 用于 goroutines 间通信。<ul><li><a href="https://go.dev/tour/concurrency/2">Go 官方文档 - Channels</a></li></ul></li><li><strong>WaitGroup</strong>：<br>了解如何使用 <code>sync.WaitGroup</code> 等待所有 goroutines 完成。<ul><li><a href="https://pkg.go.dev/sync#WaitGroup">WaitGroup 示例</a></li></ul></li></ul><hr><h3 id="3-实践简单工作池"><a href="#3-实践简单工作池" class="headerlink" title="3. 实践简单工作池"></a>3. <strong>实践简单工作池</strong></h3><p>先实现一个简单的工作池，熟悉基本流程。<br>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="keyword">for</span> job := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;Worker %d processing job %d\n&quot;</span>, id, job)</span><br><span class="line">        time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 模拟任务处理</span></span><br><span class="line">        results &lt;- job * <span class="number">2</span>          <span class="comment">// 返回结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> numJobs = <span class="number">5</span></span><br><span class="line">    <span class="keyword">const</span> numWorkers = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, numJobs)</span><br><span class="line">    results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, numJobs)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= numWorkers; w++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(w, jobs, results, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= numJobs; j++ &#123;</span><br><span class="line">        jobs &lt;- j</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(jobs)</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> res := <span class="keyword">range</span> results &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Result:&quot;</span>, res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h3 id="4-深入理解工作池模式的应用"><a href="#4-深入理解工作池模式的应用" class="headerlink" title="4. 深入理解工作池模式的应用"></a>4. <strong>深入理解工作池模式的应用</strong></h3><ul><li>扩展任务类型：如 I&#x2F;O 密集型任务（网络请求）和 CPU 密集型任务。</li><li>实现动态调整任务队列大小。</li><li>学习如何优雅地退出工作池（使用 <code>context</code> 或带超时的 <code>channels</code>）。</li></ul><hr><h3 id="5-阅读优质资源"><a href="#5-阅读优质资源" class="headerlink" title="5. 阅读优质资源"></a>5. <strong>阅读优质资源</strong></h3><ul><li><a href="https://go.dev/blog/pipelines">Go Concurrency Patterns (官方博客)</a></li><li><a href="https://www.oreilly.com/library/view/go-programming-blueprints/9781783981324/">《Go Programming Blueprints》</a></li><li><a href="https://go.dev/doc/effective_go#concurrency">Effective Go - Concurrency</a></li></ul><hr><h3 id="6-挑战真实项目"><a href="#6-挑战真实项目" class="headerlink" title="6. 挑战真实项目"></a>6. <strong>挑战真实项目</strong></h3><p>实践是掌握模式的最佳方式，可以尝试：</p><ul><li>爬取多个网页内容并解析数据。</li><li>并发处理文件或图片。</li><li>实现一个 URL 检查器（如我们之前讨论的例子）。</li></ul><hr><p>通过从基础到实战的学习，你会对 Go 的工作池模式有深刻的理解。如果有问题，可以随时向我求助！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习 Go 的工作池模式，你可以按照以下步骤系统掌握：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-理解工作池模式的概念&quot;&gt;&lt;a href=&quot;#1-理解工作池模式的概念&quot; class=&quot;headerlink&quot; title=&quot;1. 理解工作池模式的概念&quot;&gt;&lt;/a&gt;1. &lt;stron</summary>
      
    
    
    
    <category term="backend" scheme="https://whuichenggong.github.io/categories/backend/"/>
    
    
  </entry>
  
  <entry>
    <title>Go天生的并发优势</title>
    <link href="https://whuichenggong.github.io/2025/01/14/backend/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>https://whuichenggong.github.io/2025/01/14/backend/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</id>
    <published>2025-01-14T03:03:02.091Z</published>
    <updated>2025-05-11T07:11:06.337Z</updated>
    
    <content type="html"><![CDATA[<p>借鉴文章： </p><p><a href="https://www.topgoer.com/">https://www.topgoer.com/</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次的执行结果只打印了main goroutine done!，并没有打印Hello Goroutine!。为什么呢？</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>当main()函数返回的时候该goroutine就结束了，所有在main()函数中启动的goroutine会一同结束，main函数所在的goroutine就像是权利的游戏中的夜王，其他的goroutine都是异鬼，夜王一死它转化的那些异鬼也就全部GG了。</p><p>所以我们要想办法让main函数等一等hello函数，最简单粗暴的方式就是time.Sleep了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> hello() <span class="comment">// 启动另外一个goroutine去执行hello函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main goroutine done!&quot;</span>)</span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动多个goroutine"><a href="#启动多个goroutine" class="headerlink" title="启动多个goroutine"></a>启动多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done() <span class="comment">// goroutine结束就登记-1</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Hello Goroutine!&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>) <span class="comment">// 启动一个goroutine就登记+1</span></span><br><span class="line">        <span class="keyword">go</span> hello(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait() <span class="comment">// 等待所有登记的goroutine都结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 合起来写</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Printf(<span class="string">&quot;new goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line"><span class="comment">//time.Sleep(time.Second)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i++</span><br><span class="line">fmt.Printf(<span class="string">&quot;main goroutine: i = %d\n&quot;</span>, i)</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line"><span class="keyword">if</span> i == <span class="number">3</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>在这段程序中 如果 注释 &#x2F;&#x2F;time.Sleep(time.Second)这个语句：</p><p>新 goroutine 中的无限循环运行非常快，因为 time.Sleep 被注释掉了。</p><p>新 goroutine 的打印操作占据了 CPU 的大部分时间，导致主 goroutine 很少或者几乎没有机会运行。</p><p>Go 的 goroutine 是由 Go 运行时管理的轻量级线程，<strong>采用抢占式调度。</strong></p><p>在你的代码中，新 goroutine 中的打印操作和循环执行非常快，没有阻塞点（比如 time.Sleep 或 I&#x2F;O 操作）。</p><p>没有阻塞点会让新 goroutine 占据大量的 CPU 时间，主 goroutine 反而无法得到足够的调度时间。</p><p>主 goroutine 需要与新 goroutine 竞争 CPU 时间。<br>因为新 goroutine 的循环过于频繁（没有阻塞），主 goroutine 可能无法及时获得 CPU 调度机会。</p><h3 id="Go中的调度函数使用"><a href="#Go中的调度函数使用" class="headerlink" title="Go中的调度函数使用"></a>Go中的调度函数使用</h3><p>runtime.Gosched 的作用：<br>暂停当前 goroutine 的执行。<br>将 CPU 的使用机会交还给调度器。<br>调度器会决定下一个应该执行的 goroutine。</p><p>GPM是Go语言运行时（runtime）层面的实现，</p><p>在你提供的程序中，主 goroutine 是 main 函数中的代码执行流。具体来说，程序一开始会执行 main() 函数内的内容。<br>然后，主 goroutine 会启动一个新的后台 goroutine，<br>通过 go 关键字启动的匿名函数来执行，这个新 goroutine 会执行打印 “world” 的任务。</p><h4 id="GPM"><a href="#GPM" class="headerlink" title="GPM"></a>GPM</h4><ol><li><p>G (Goroutine)：<br>表示一个具体的 goroutine，包含要执行的任务信息，比如函数栈、指令等。<br>G 是任务的最小单位。</p></li><li><p>P (Processor)：<br>是一个逻辑处理器，用于管理 goroutine 的运行队列。<br>P 和 CPU 核心的数量绑定（通过 GOMAXPROCS 控制），每个 P 会调度多个 G。</p></li><li><p>M (Machine)：<br>表示一个操作系统线程。<br>M 从 P 的队列中获取 G 并执行它。<br>每个 M 会从 P 上获取一个或多个 G 来执行。</p></li></ol><p>在 Go 的 GPM 调度模型中，P 和 M 之间的关系是 一对多，<br>即每个 P（处理器）可以关联多个 M（操作系统线程），但同一时刻每个 P 只有一个 M 处于 活跃 状态，<br>来执行调度的任务（即执行 G，即 goroutine）。</p><h3 id="可增长的栈"><a href="#可增长的栈" class="headerlink" title="可增长的栈"></a>可增长的栈</h3><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine的栈在其生命周期开始时只有很小的栈（典型情况下2KB），<br>goroutine的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB，虽然极少会用到这个大。<br>所以在Go语言中一次创建十万左右的goroutine也是可以的。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步执行的核心思想是让某些任务在后台运行，不阻塞主流程。</p><p>go a(ch) 启动 a 函数的执行，但不会阻塞主 goroutine，主 goroutine 可以继续执行后续代码。<br>a(ch) 在后台运行，它执行完后通过 channel 通知主 goroutine。<br>主 goroutine 等待 signal，通过 &lt;-ch 实现同步等待，确保 a 完成后才继续后续操作。<br>因此，go a(ch) 启动的部分是异步的，意味着 a 会在后台执行，而主 goroutine 不会因调用 a 而阻塞或等待它完成。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>单纯地将函数并发执行是没有意义的。函数与函数间需要交换数据才能体现并发执行函数的意义。</p><p>虽然可以使用共享内存进行数据交换，但是共享内存在不同的goroutine中容易发生竞态问题。<br>为了保证数据交换的正确性，必须使用互斥量对内存进行加锁，这种做法势必造成性能问题。</p><p>Go语言的并发模型是CSP（Communicating Sequential Processes），提倡通过<strong>通信共享内存</strong>而不是通过共享内存而实现通信。</p><p>channel就是它们之间的连接。channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。</p><p>Go 语言中的通道（channel）是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，<br>保证收发数据的顺序。每一个通道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型</p><p>关闭后的通道有以下特点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.对一个关闭的通道再发送值就会导致panic。</span><br><span class="line"> 2.对一个关闭的通道进行接收会一直获取值直到通道为空。</span><br><span class="line"> 3.对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</span><br><span class="line"> 4.关闭一个已经关闭的通道会导致panic。</span><br></pre></td></tr></table></figure><h3 id="无缓冲的通道-同步通道"><a href="#无缓冲的通道-同步通道" class="headerlink" title="无缓冲的通道(同步通道)"></a>无缓冲的通道(同步通道)</h3><p>无缓冲的通道又称为阻塞的通道</p><p>启用一个goroutine去接收值</p><p>无缓冲通道上的发送操作会阻塞，直到另一个goroutine在该通道上执行接收操作，这时值才能发送成功，两个goroutine将继续执行。相反，如果接收操作先执行，接收方的goroutine将阻塞，直到另一个goroutine在该通道上发送一个值。</p><p>可以通过内置的close()函数关闭channel（如果你的管道不往里存值或者取值的时候一定记得关闭管道）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            c &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> data, ok := &lt;-c; ok &#123;</span><br><span class="line">            fmt.Println(data)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;main结束&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;借鉴文章： &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.topgoer.com/&quot;&gt;https://www.topgoer.com/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="backend" scheme="https://whuichenggong.github.io/categories/backend/"/>
    
    
  </entry>
  
  <entry>
    <title>go中的context</title>
    <link href="https://whuichenggong.github.io/2025/01/02/go/%E8%B0%83%E7%94%A8/"/>
    <id>https://whuichenggong.github.io/2025/01/02/go/%E8%B0%83%E7%94%A8/</id>
    <published>2025-01-02T09:34:59.595Z</published>
    <updated>2025-05-11T07:12:26.998Z</updated>
    
    <content type="html"><![CDATA[<p>首先理解同步调用与异步调用：</p><p><strong>同步调用</strong>和<strong>异步调用</strong>是两种常见的函数调用方式，尤其在多线程、并发编程中，这两种方式对程序的执行流程和效率有着直接影响。</p><h3 id="1-同步调用（Synchronous-Call）"><a href="#1-同步调用（Synchronous-Call）" class="headerlink" title="1. 同步调用（Synchronous Call）"></a>1. <strong>同步调用（Synchronous Call）</strong></h3><p>同步调用是指函数调用时，调用者会等待被调用的函数执行完毕并返回结果之后，才能继续执行后续操作。在同步调用过程中，函数的调用者会<strong>阻塞</strong>，直到函数执行完成。</p><p><strong>特点</strong>：</p><ul><li><strong>阻塞</strong>：调用者会等待被调用的函数执行完成，才会继续执行后续代码。</li><li><strong>执行顺序</strong>：代码按顺序执行，当前任务完成后，才能继续下一个任务。</li></ul><p><strong>举个例子</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个同步调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Long task finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Start task&quot;</span>)</span><br><span class="line">    longTask()  <span class="comment">// 同步调用，调用者会等待该函数执行完</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;End task&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start task</span><br><span class="line">Long task finished</span><br><span class="line">End task</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>longTask()</code> 函数执行时，程序会等待它执行完毕，然后才继续执行后面的 <code>fmt.Println(&quot;End task&quot;)</code>。</p><h3 id="2-异步调用（Asynchronous-Call）"><a href="#2-异步调用（Asynchronous-Call）" class="headerlink" title="2. 异步调用（Asynchronous Call）"></a>2. <strong>异步调用（Asynchronous Call）</strong></h3><p>异步调用是指调用者在调用函数时，不会等待函数执行完成，而是直接继续执行后续代码。异步调用通常会通过某种机制（比如回调函数、线程、goroutine等）来处理函数执行完成后的结果。</p><p><strong>特点</strong>：</p><ul><li><strong>非阻塞</strong>：调用者不会等待被调用的函数执行完成，而是继续执行后续操作。</li><li><strong>执行顺序</strong>：调用者继续执行，而被调用的函数可能在后台执行，执行顺序不确定。</li></ul><p><strong>举个例子（使用 Go 的 goroutine）</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟一个异步调用的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Long task finished&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Start task&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> longTask()  <span class="comment">// 异步调用，goroutine 不会阻塞主线程</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;End task&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">3</span> * time.Second)  <span class="comment">// 等待 goroutine 执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Start task</span><br><span class="line">End task</span><br><span class="line">Long task finished</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>longTask()</code> 被异步调用（通过 <code>go</code> 关键字），主线程并不会等待 <code>longTask()</code> 执行完毕，而是继续执行 <code>fmt.Println(&quot;End task&quot;)</code>。由于 <code>longTask()</code> 是在一个新的 goroutine 中执行的，所以它会在主线程打印完 <code>&quot;End task&quot;</code> 后才完成。</p><h3 id="同步调用与异步调用的区别："><a href="#同步调用与异步调用的区别：" class="headerlink" title="同步调用与异步调用的区别："></a><strong>同步调用与异步调用的区别</strong>：</h3><table><thead><tr><th><strong>特性</strong></th><th><strong>同步调用</strong></th><th><strong>异步调用</strong></th></tr></thead><tbody><tr><td><strong>执行方式</strong></td><td>当前任务需要等待被调用函数执行完毕后才能继续</td><td>当前任务不会等待，被调用函数在后台执行</td></tr><tr><td><strong>阻塞与非阻塞</strong></td><td>阻塞：调用者会等待被调用函数完成</td><td>非阻塞：调用者不会等待被调用函数完成，继续执行</td></tr><tr><td><strong>执行顺序</strong></td><td>按顺序执行，当前任务完成后，继续下一个任务</td><td>执行顺序不确定，被调用函数可能稍后执行</td></tr><tr><td><strong>适用场景</strong></td><td>适用于需要等待函数执行完成后才能继续的情况</td><td>适用于可以并行处理，调用者不需要等待结果的情况</td></tr><tr><td><strong>效率</strong></td><td>效率较低，尤其在调用高延时操作时，调用者会被阻塞</td><td>效率较高，可以并行执行多个任务，不阻塞调用者</td></tr></tbody></table><h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a><strong>优缺点</strong>：</h3><ul><li><p><strong>同步调用</strong>：</p><ul><li><strong>优点</strong>：简单，易于理解和调试，程序的执行顺序清晰。</li><li><strong>缺点</strong>：当操作耗时较长时，调用者需要等待，造成性能瓶颈。例如，I&#x2F;O 密集型操作（如数据库查询、网络请求等）可能导致程序停滞。</li></ul></li><li><p><strong>异步调用</strong>：</p><ul><li><strong>优点</strong>：提高并发性能，特别适合处理 I&#x2F;O 密集型操作。调用者不需要等待操作完成，可以同时执行多个任务。</li><li><strong>缺点</strong>：需要更多的设计和管理，比如回调函数、并发控制等；调试和错误处理可能比较复杂。</li></ul></li></ul><h3 id="何时选择同步和异步？"><a href="#何时选择同步和异步？" class="headerlink" title="何时选择同步和异步？"></a><strong>何时选择同步和异步？</strong></h3><ul><li><strong>同步调用</strong>：适用于需要按顺序执行任务且任务之间有依赖关系的场景。例如，计算任务需要按顺序完成，或者需要等待数据库查询结果再执行下一步操作。</li><li><strong>异步调用</strong>：适用于任务之间没有直接依赖关系，可以并行执行的场景。例如，网络请求、文件处理、并发计算等。</li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><ul><li><strong>同步调用</strong>是阻塞的，调用者需要等待被调用函数执行完成后才能继续执行后续代码。</li><li><strong>异步调用</strong>是非阻塞的，调用者不会等待被调用函数执行完成，而是继续执行后续操作，通常通过回调或并发机制处理结果。</li></ul><h2 id="并发相关能力："><a href="#并发相关能力：" class="headerlink" title="并发相关能力："></a>并发相关能力：</h2><p>创建了一个异步的协程或者线程，如果你不知道它什么时候终止，最好不要创建它！ 做到心中有数，理解并发！什么时候该用</p><p>线程： 是cpu需要执行的任务</p><p>并发执行，看似在一起做实行，如果是一个cpu核心那么：实则是一个人在两个任务之间快速的切换！（本质还是一个人做两件事，只不过两件事都分别分配一点时间）</p><p>两个核心执行两个线程 就相当于并行执行两个任务，时间将会被大大缩短</p><p>但是实际情况还是会非常复杂：</p><p>锁机制：</p><p>即使有两个cpu可以工作，但是他们需要持有锁的那个才可以工作！这也就导致了实际的工作还是并发执行！</p><p>高性能程序尽量避免使用锁</p><p>context之间形成多叉树的结构！</p><p>父ctx派生 多个子ctx</p><p>感知生命周期  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先理解同步调用与异步调用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步调用&lt;/strong&gt;和&lt;strong&gt;异步调用&lt;/strong&gt;是两种常见的函数调用方式，尤其在多线程、并发编程中，这两种方式对程序的执行流程和效率有着直接影响。&lt;/p&gt;
&lt;h3 id=&quot;1-同步调用（Syn</summary>
      
    
    
    
    <category term="go" scheme="https://whuichenggong.github.io/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>软技能</title>
    <link href="https://whuichenggong.github.io/2025/01/02/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    <id>https://whuichenggong.github.io/2025/01/02/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/%E8%BD%AF%E6%8A%80%E8%83%BD/</id>
    <published>2025-01-02T03:55:16.442Z</published>
    <updated>2025-05-11T07:13:05.521Z</updated>
    
    <content type="html"><![CDATA[<p>书中的前言： 引用的几句名言！</p><p>“现在的困难可能会成为未来的趋势”</p><p>“站在对方的角度，在说服对方的时候，为他准备好解决问题的方案”</p><p>“不浪费任何一次危机，任何危机都是组织结构重新组合的重大契机”</p><p>“作为听者，你能理解表达能力较弱的一方的言说，作为言说者，你能让理解力较弱的一方明白你的意思”</p><hr><p>组合型思维： 我这里强，需要你那里强，互相配合，达到双赢，</p><p>多想：</p><p>你能为别人做什么，你能为圈子带来什么。为什么小的时候看什么都新奇，到那时长大后变得更加麻木了呢？对周围事物，没有了其他想法<br>是不是思维被固定住了呢？ 保持孩童般的惊奇！</p><p>主动创造不平凡：</p><p>有些人就是不甘于平凡！才会造就出一些令世人震惊的事物。</p><p>做事情的两种方法：</p><ol><li>做减法：<br>拿出一段时间，排除各种琐事的干扰，降低认知负荷，集中能量，完全自主就干这一件事</li><li>做加法<br>主动给事情增加难度，你觉得没意思，可以去悬崖边看书哈哈哈，真的可以，但是要注意安全呢</li></ol><p>但是，世界上有很多事情根本不需要去做，还有些事情是不能去做的！，被别人认可的事情就是一定是好的吗？可能你在你只是在一些无意义的事做了循环<br>无用功</p><p>所以，如何判断哪些事需要做，哪些是不能做！这也是一个人的能力</p><p>有效的反馈系统： 一件事该不该做，通常是需要总结之前做事的结果，做一件事后产生的预期结果之后<br>分析做成的原因， 运气？or 实力？自己心里要清楚<br>没有达到预期的事情，花时间想问题出在了哪里？调整自己的行为</p><p>培养同理心：培养理解他人的能力，站在对方的角度思考问题，</p><p>”辛辛苦苦发明一样东西，却发现世界并不需要他“：  创新和实际需求之间的鸿沟</p><p>保持敬畏心：</p><p>（愿意去学习、去探索，而不是自以为是或过于自信。承认自然界的复杂性和不确定性，推动自己不断探索。）愿意通过反思和努力去改进</p><p>技能是无限的，我们的时间和精力是有限的，造成结果就是，我们对一切事物只能做到一知半解，很多技能也掌握的二把刀水平，对于自己力所不能及的事情，不要去做<br>力所能及的事情，做起来也要留三分（可以在完成的基础上保持精力和资源的余地，为未来的工作或挑战做好准备。）</p><p>剥离情感（但不等同于没有同理心）：</p><p>很多事，自己的情感卷进去就不好了，同理心要求我们摒弃以自我为中心的想法，剥离情感是让我们不要被情感牵着鼻子走，保持客观公正的判断力！</p><p>改变模式而不是放弃机遇：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;书中的前言： 引用的几句名言！&lt;/p&gt;
&lt;p&gt;“现在的困难可能会成为未来的趋势”&lt;/p&gt;
&lt;p&gt;“站在对方的角度，在说服对方的时候，为他准备好解决问题的方案”&lt;/p&gt;
&lt;p&gt;“不浪费任何一次危机，任何危机都是组织结构重新组合的重大契机”&lt;/p&gt;
&lt;p&gt;“作为听者，你能理解表</summary>
      
    
    
    
    <category term="书后心得" scheme="https://whuichenggong.github.io/categories/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>你的灯还亮着吗</title>
    <link href="https://whuichenggong.github.io/2024/12/28/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/%E7%9C%8B%E4%BA%86%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <id>https://whuichenggong.github.io/2024/12/28/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/%E7%9C%8B%E4%BA%86%E4%B8%80%E6%9C%AC%E4%B9%A6/</id>
    <published>2024-12-28T10:40:19.406Z</published>
    <updated>2025-05-11T07:20:03.586Z</updated>
    
    <content type="html"><![CDATA[<p>今天一下午的时间看了这本书，对我的感触很大，很有助于思考，对于一个问题的思考，一种问题不同的问法，产生不同的问题</p><p>文字游戏：一句话不同的停顿产生不同的问题</p><p>有些事情是不是简单的问题复杂化（这应该是普遍现象） 复杂的问题简单化（很少）</p><p>你是不是真的想要解决这问题？</p><p>追溯本源，从一个婴儿视角重新审视这个问题！</p><p>一生二，二生三，三生万物： 你对一个问题的解决（是否是真的解决？）一个问题的解决必然产生另一个问题的产生！</p><p>看看你是否能从一个问题的解决，来想到它产生了3个其他的问题？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天一下午的时间看了这本书，对我的感触很大，很有助于思考，对于一个问题的思考，一种问题不同的问法，产生不同的问题&lt;/p&gt;
&lt;p&gt;文字游戏：一句话不同的停顿产生不同的问题&lt;/p&gt;
&lt;p&gt;有些事情是不是简单的问题复杂化（这应该是普遍现象） 复杂的问题简单化（很少）&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="书后心得" scheme="https://whuichenggong.github.io/categories/%E4%B9%A6%E5%90%8E%E5%BF%83%E5%BE%97/"/>
    
    
  </entry>
  
  <entry>
    <title>一位老哥的分享给了我一些启发</title>
    <link href="https://whuichenggong.github.io/2024/12/18/%E7%94%9F%E6%B4%BB/live3/"/>
    <id>https://whuichenggong.github.io/2024/12/18/%E7%94%9F%E6%B4%BB/live3/</id>
    <published>2024-12-18T12:43:19.542Z</published>
    <updated>2025-01-21T07:09:45.201Z</updated>
    
    <content type="html"><![CDATA[<p>学习方法：老哥的思维方式也给了我一些启发</p><p>以下是老哥的分享：</p><p>当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考</p><p>因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 </p><p>所以第一步我做的是把长长的博客尽量拆解为小的讨论主题</p><p>作为”词条”存在</p><p>比如我写了个k8s主题的词条 写道”容器”这个词会自动链接到我之前写过的容器相关的内容  里面的内容是否符合当下我需要的定义  如果是, 那么可以知识复用  如果不是, 那么我需不需要创建新的词条来讨论这个主题<br>然后关联知识形成网络</p><p>比如一个使用mysql + reids搭建的系统, 即用到了mysql, 又用到了redis, 同时它本身还是个系统设计就会难以归类 </p><p>但是 一个文章可以同时带有mysql, redis, 系统设计三种tag  让知识形成网络！</p><p>先把书的标题提取出来 建立一个词条  然后去网上查, 这个东西包含哪些东西 然后去网上查, 这个东西包含哪些东西 等熟悉了基于零散信息的网络后  再去快速浏览权威书籍 迭代网络  </p><hr><p>听了老哥的分享！ 我觉得自己再生活中真的缺乏太多的思考了！什么事知道他困难，不想办法，应该去思考一些东西才能让东西变得更活！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习方法：老哥的思维方式也给了我一些启发&lt;/p&gt;
&lt;p&gt;以下是老哥的分享：&lt;/p&gt;
&lt;p&gt;当知识点量大起来时, 我觉得”写作”的意义应该在于辅助思考&lt;/p&gt;
&lt;p&gt;因为短时间内可能我们能记得很好, 但是对于长时间的庞大知识体系的学习, 就容易忘记一些分支内容 &lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="生活" scheme="https://whuichenggong.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>学习数据库</title>
    <link href="https://whuichenggong.github.io/2024/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Database/"/>
    <id>https://whuichenggong.github.io/2024/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Database/</id>
    <published>2024-12-16T01:12:34.566Z</published>
    <updated>2025-05-11T07:15:27.292Z</updated>
    
    <content type="html"><![CDATA[<hr><p>参考书籍： 数据库设计</p><hr><p>我先从事务入手：</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>概念</strong> ： 与单个用户或者程序执行，完成读取或者更新数据库内容的一个或一串操作</p><p>应用程序的一次执行就是一个事务或者多个事务</p><p>示例：</p><p>简单事务： 更新x员工的工资（涉及：数据库的读和写，和非数据库操作）</p><p>复杂事务：删除x的员工记录，并把x员工的事务交付给其他人去做。 （过程中若并非所有的操作都被执行，那么数据库的引用完整性将遭到破坏）（数据库也处于不一致状态）</p><p>尽管一致性暂时遭到破坏，但是数据库总是可以从一种一致状态转换到另一种一致的状态</p><h3 id="数据库最终的结果"><a href="#数据库最终的结果" class="headerlink" title="数据库最终的结果"></a>数据库最终的结果</h3><ol><li>COMMIT：执行成功，事务最终被提交 （数据库也达到了一种新的状态）</li><li>ABORTED：事务没有执行成功 （事务被撤销）则数据库必须要还原事务开始之前的一致状态</li><li>已经提交的事务不能被撤销，只能通过（补偿事务）进行覆盖 消除事务产生的影响</li><li>DBMS将在程序正确结束后自动执行COMMIT操作，若不能成功执行则 ROBACK</li><li>PARTIALLY COMITTED：若在最后一条语句被执行时产生了 破坏了可串行化或违反了完整约束 因此事务必须被撤销 或者系统出现故障，事务更新的事务没有被安全的写到二级存储设备上（部分提交） 以上两种情况最终都会进入</li><li>FAILED（失败状态） 事务无法被提交，或者事务处于ACTIVE状态就被撤销 则 处于FAILED状态</li></ol><h3 id="事务性质"><a href="#事务性质" class="headerlink" title="事务性质"></a>事务性质</h3><p>ACID</p><ol><li>原子性：</li><li>一致性：</li><li>隔离性：</li><li>持久性：</li></ol><p>事务的隔离级别<br>事务隔离级别控制了事务之间的可见性和并发行为。常见的隔离级别包括：</p><ul><li>读未提交（Read Uncommitted）：在这个隔离级别下，一个事务可以读取其他事务尚未提交的数据。这可能导致脏读（读取了未提交的数据）、不可重复读（同一查询在事务执行期间返回不同结果）和幻读（事务在同一查询中看到不同的数据行）等问题。读未提交的隔离级别最不严格，可能会引发数据不一致问题</li><li>读已提交（Read Committed）：在这个隔离级别下，一个事务只能读取已经提交的数据，避免了脏读问题。但是，不可重复读和幻读问题仍然可能出现。因为其他事务可能在事务进行期间提交新的数据，导致不同时间点的查询结果不一致。</li><li>可重复读（Repeatable Read）：可重复读隔离级别确保在同一事务内，同一个查询的结果保持一致。这意味着一个事务中的查询不会受到其他事务的修改影响。这可以防止脏读和不可重复读问题，但幻读问题仍然可能出现，因为其他事务可能插入新数据，导致新数据行的出现。</li><li>串行化（Serializable）：串行化是最严格的隔离级别，它确保每个事务都在独立的时间段内执行，防止了并发问题。事务按照顺序一个接一个地执行，这可以解决脏读、不可重复读和幻读问题。然而，串行化可能会对性能产生较大的影响，因为事务需要依次执行。</li></ul><p>事务的隔离级别可以解决脏读、幻读、不可重复读的问题。</p><ol><li>脏读： 脏读指的是在一个事务中读取了另一个事务未提交的数据。假设事务 A 修改了某一行数据，但还没有提交。同时，事务 B 尝试读取了事务 A 修改的数据。如果事务 A 最终回滚了，那么事务 B 读取的数据就是不存在的，这就是脏读。脏读会导致不准确的数据展示，因为<strong>读取的数据可能是临时的未经验证的。</strong>、</li><li>不可重复读：不可重复读是指在同一个事务内，多次读取同一数据时，得到不同的结果。这可能是因为在事务执行期间，其他事务修改了数据。例如，事务 A 在读取某一行数据后，事务 B 修改了这行数据，并提交了。现在事务 A 再次读取相同的数据，注重数据：<strong>发现数据已经不同了</strong>，造成了不一致的现象。</li><li>幻读： 幻读是指在同一个事务内，多次查询同一范围的数据时，得到不同的结果。这与不可重复读类似，但幻读关注的是数据的数量变化。例如，事务 A 在查询某个范围内的所有数据时，事务 B 插入了新数据，并提交了。现在事务 A 再次查询同一范围的数据，注重：<strong>发现数据行的数量增加了</strong>，这就是幻读。</li></ol><hr><p>22.2 并发控制 </p><p>讲解了数据库中的一些问题 幻读等</p><p>[点击这里查看PDF文件] (<a href="https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf">https://github.com/Whuichenggong/Knowledge-network/blob/main/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BD%91%E7%BB%9C.pdf</a>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;参考书籍： 数据库设计&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我先从事务入手：&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt; ： 与单个</summary>
      
    
    
    
    <category term="计算机系统" scheme="https://whuichenggong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>关于我学习的一些资源和方法</title>
    <link href="https://whuichenggong.github.io/2024/12/15/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/resource/"/>
    <id>https://whuichenggong.github.io/2024/12/15/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/resource/</id>
    <published>2024-12-15T07:45:03.995Z</published>
    <updated>2025-05-11T07:13:50.108Z</updated>
    
    <content type="html"><![CDATA[<p>兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。</p><hr><h3 id="学习资料推荐"><a href="#学习资料推荐" class="headerlink" title="学习资料推荐"></a><strong>学习资料推荐</strong></h3><h4 id="1-数据库相关"><a href="#1-数据库相关" class="headerlink" title="1. 数据库相关"></a><strong>1. 数据库相关</strong></h4><ul><li><strong>书籍</strong>：《高性能 MySQL》<ul><li>重点阅读：索引优化、事务机制、查询优化。</li><li><strong>免费在线教程</strong>：<ul><li><a href="https://www.w3schools.com/sql/">SQL 教程（w3schools）</a></li><li><a href="https://dev.mysql.com/doc/">MySQL 官方文档</a></li></ul></li></ul></li></ul><h4 id="2-计算机网络"><a href="#2-计算机网络" class="headerlink" title="2. 计算机网络"></a><strong>2. 计算机网络</strong></h4><ul><li><strong>书籍</strong>：《计算机网络：自顶向下方法》或《图解HTTP》<ul><li>重点章节：HTTP、TCP&#x2F;IP、DNS、HTTPS。</li><li><strong>免费资源</strong>：<ul><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1030595307488672">HTTP 协议详解</a></li><li><a href="https://www.wireshark.org/">Wireshark 网络分析教程</a></li></ul></li></ul></li></ul><h4 id="3-操作系统"><a href="#3-操作系统" class="headerlink" title="3. 操作系统"></a><strong>3. 操作系统</strong></h4><ul><li><strong>书籍</strong>：《现代操作系统》<ul><li>重点章节：进程、线程、同步、内存管理。</li><li><strong>免费资源</strong>：<ul><li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/">Operating Systems: Three Easy Pieces</a></li><li><a href="https://www.linuxfoundation.org/">Linux 操作系统入门</a></li></ul></li></ul></li></ul><h4 id="4-系统设计"><a href="#4-系统设计" class="headerlink" title="4. 系统设计"></a><strong>4. 系统设计</strong></h4><ul><li><strong>书籍</strong>：《系统设计入门》（Grokking the System Design Interview）<ul><li>重点学习：缓存、负载均衡、限流。</li><li><strong>博客</strong>：<ul><li><a href="https://www.educative.io/courses/grokking-the-system-design-interview">系统设计基础</a></li></ul></li></ul></li></ul><h4 id="5-Redis"><a href="#5-Redis" class="headerlink" title="5. Redis"></a><strong>5. Redis</strong></h4><ul><li><strong>书籍</strong>：《Redis 实战》<ul><li>重点章节：缓存机制、分布式锁。</li><li><strong>免费资源</strong>：<ul><li><a href="https://redis.io/docs/">Redis 官方文档</a></li></ul></li></ul></li></ul><h4 id="6-算法与数据结构"><a href="#6-算法与数据结构" class="headerlink" title="6. 算法与数据结构"></a><strong>6. 算法与数据结构</strong></h4><ul><li><strong>书籍</strong>：《算法（第4版）》或《编程珠玑》<ul><li>重点章节：常用数据结构（栈、队列、二叉树）、动态规划。</li><li><strong>网站</strong>：<ul><li><a href="https://leetcode.com/">LeetCode 官方</a></li><li><a href="https://visualgo.net/">VisuAlgo（算法可视化）</a></li></ul></li></ul></li></ul><hr><h3 id="高效看书方法"><a href="#高效看书方法" class="headerlink" title="高效看书方法"></a><strong>高效看书方法</strong></h3><h4 id="1-目的导向阅读"><a href="#1-目的导向阅读" class="headerlink" title="1. 目的导向阅读"></a><strong>1. 目的导向阅读</strong></h4><ul><li><strong>明确目标</strong>：每次看书前，明确你要解决的问题。比如：<ul><li>“我需要理解事务是怎么实现的” → 阅读事务相关章节，跳过其他部分。</li><li>“我需要掌握 TCP 的连接过程” → 只看 TCP 的工作原理。</li></ul></li></ul><h4 id="2-略读和精读结合"><a href="#2-略读和精读结合" class="headerlink" title="2. 略读和精读结合"></a><strong>2. 略读和精读结合</strong></h4><ul><li><strong>略读</strong>：先快速翻阅目录和每章的开头，总结书的主要内容。</li><li><strong>精读</strong>：挑选与项目或刷题直接相关的部分深入看，配合做笔记和练习。</li></ul><h4 id="3-配合实践"><a href="#3-配合实践" class="headerlink" title="3. 配合实践"></a><strong>3. 配合实践</strong></h4><ul><li><strong>边学边做</strong>：看完书中某个知识点，立即在项目或代码中实现。<ul><li>例子：学完 Redis 的分布式锁，马上在银行项目中添加。</li></ul></li><li><strong>用书作为工具</strong>：书可以成为你的“随手参考”，遇到不懂的概念再翻阅相关章节，而不必一次性啃完。</li></ul><h4 id="4-输出内容"><a href="#4-输出内容" class="headerlink" title="4. 输出内容"></a><strong>4. 输出内容</strong></h4><ul><li><strong>写笔记</strong>：总结书中学到的知识，用自己的语言重新描述。</li><li><strong>录制分享</strong>：试着用 3 分钟向别人讲解你刚学的内容，加深记忆。</li></ul><h4 id="5-番茄工作法"><a href="#5-番茄工作法" class="headerlink" title="5. 番茄工作法"></a><strong>5. 番茄工作法</strong></h4><ul><li>每次阅读 25 分钟后，花 5 分钟总结这段时间的收获，然后休息片刻。效率会提升很多。</li></ul><hr><h3 id="实践与看书的时间分配"><a href="#实践与看书的时间分配" class="headerlink" title="实践与看书的时间分配"></a><strong>实践与看书的时间分配</strong></h3><ol><li><strong>每天早上&#x2F;晚上固定 1 小时阅读</strong>。<ul><li>比如：早上看《高性能 MySQL》，晚上看《计算机网络》。</li></ul></li><li><strong>实践时遇到问题，马上查书解决</strong>。<ul><li>例子：如果 Redis 配置缓存遇到问题，就查《Redis 实战》。</li></ul></li><li><strong>每周末专门安排 2 小时总结书中知识点，结合项目整理成笔记</strong>。</li></ol><hr><p>这样安排既能保持实践的节奏，又能让你从书中挖掘深层的原理。如果还有具体内容不理解，可以随时问我，我也可以帮你分解章节内容！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;兄弟，我理解你的心态，觉得实践的收获更直观，看书反而有点慢。但实际上，看书和实践结合，效果会倍增。下面我不仅推荐优质资源，还会分享高效阅读的方法，帮你更好地平衡学习时间。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;学习资料推荐&quot;&gt;&lt;a href=&quot;#学习资料推荐&quot; class=&quot;h</summary>
      
    
    
    
    <category term="技术分享" scheme="https://whuichenggong.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
    
  </entry>
  
  <entry>
    <title>聊聊最近</title>
    <link href="https://whuichenggong.github.io/2024/12/12/%E7%94%9F%E6%B4%BB/current/"/>
    <id>https://whuichenggong.github.io/2024/12/12/%E7%94%9F%E6%B4%BB/current/</id>
    <published>2024-12-12T12:57:12.010Z</published>
    <updated>2025-05-11T07:20:03.575Z</updated>
    
    <content type="html"><![CDATA[<p>最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用<br>我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶性循环，本想着晚上回去看会<br>书，自己却暗示自己，学一天了，玩吧哈哈哈。好像都没做，但是确实没有那么重要，吃饭可以让同学帮我付，哈哈，还是得学习呢，反省一下，是不是你想要的太多了<br>而导致你很累，那种精神上的压迫自己，反思~</p><p>今天12.12日试着实现将单片机的数据传输到数据库中交互<br>先简单的使用按钮的高低电平0 1 实现交互试试看</p><p>后端服务代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/jackc/pgx/v4&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ButtonPress <span class="keyword">struct</span> &#123;</span><br><span class="line">DeviceID  <span class="type">string</span> <span class="string">`json:&quot;device_id&quot;`</span></span><br><span class="line">Button    <span class="type">int</span>    <span class="string">`json:&quot;button&quot;`</span></span><br><span class="line">Timestamp <span class="type">string</span> <span class="string">`json:&quot;timestamp&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">dbHost     = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">dbPort     = <span class="number">5432</span></span><br><span class="line">dbUser     = <span class="string">&quot;root&quot;</span></span><br><span class="line">dbPassword = <span class="string">&quot;secret&quot;</span></span><br><span class="line">dbName     = <span class="string">&quot;data&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// Set up the database connection</span></span><br><span class="line">connStr := fmt.Sprintf(<span class="string">&quot;postgresql://%s:%s@%s:%d/%s&quot;</span>, dbUser, dbPassword, dbHost, dbPort, dbName)</span><br><span class="line">conn, err := pgx.Connect(context.Background(), connStr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Unable to connect to the database: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the HTTP server</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/receive&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> r.Method != http.MethodPost &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Only POST requests are supported&quot;</span>, http.StatusMethodNotAllowed)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data ButtonPress</span><br><span class="line"><span class="keyword">if</span> err := json.NewDecoder(r.Body).Decode(&amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Invalid JSON format&quot;</span>, http.StatusBadRequest)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Received data: %+v&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> data.Button == <span class="number">1</span> &#123;</span><br><span class="line"><span class="comment">// Store the data in the database</span></span><br><span class="line">query := <span class="string">&quot;INSERT INTO button_presses (device_id, button, timestamp) VALUES ($1, $2, $3)&quot;</span></span><br><span class="line">_, err := conn.Exec(context.Background(), query, data.DeviceID, data.Button, data.Timestamp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">http.Error(w, <span class="string">&quot;Failed to store data in the database&quot;</span>, http.StatusInternalServerError)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">log.Println(<span class="string">&quot;Data successfully stored in the database&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">w.WriteHeader(http.StatusOK)</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;Data received and processed&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Starting server on 192.168.111.1:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err := http.ListenAndServe(<span class="string">&quot;192.168.111.1:8080&quot;</span>, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Server failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是简单的实现</p><p>单片机端代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266WiFi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ESP8266HTTPClient.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ssid = <span class="string">&quot;Your_SSID&quot;</span>;          <span class="comment">// Wi-Fi 名称</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* password = <span class="string">&quot;Your_PASSWORD&quot;</span>;  <span class="comment">// Wi-Fi 密码</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* serverUrl = <span class="string">&quot;http://8.222.186.212:8080/send&quot;</span>;  <span class="comment">// 后端服务器地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">  Serial.begin(<span class="number">115200</span>); <span class="comment">// 初始化串口</span></span><br><span class="line">  WiFi.begin(ssid, password);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 连接到 Wi-Fi</span></span><br><span class="line">  Serial.print(<span class="string">&quot;Connecting to Wi-Fi&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (WiFi.status() != WL_CONNECTED) &#123;</span><br><span class="line">    delay(<span class="number">1000</span>);</span><br><span class="line">    Serial.print(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(<span class="string">&quot;\nConnected to Wi-Fi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (WiFi.status() == WL_CONNECTED) &#123;</span><br><span class="line">    HTTPClient http;</span><br><span class="line">    http.begin(serverUrl);   <span class="comment">// 设置服务器 URL</span></span><br><span class="line">    http.addHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>); <span class="comment">// 设置请求头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 示例 JSON 数据</span></span><br><span class="line">    String jsonData = <span class="string">&quot;&#123;\&quot;sensor\&quot;: \&quot;temperature\&quot;, \&quot;value\&quot;: 25.5&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// POST 请求</span></span><br><span class="line">    <span class="type">int</span> httpResponseCode = http.POST(jsonData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查响应状态</span></span><br><span class="line">    <span class="keyword">if</span> (httpResponseCode &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      String response = http.getString();</span><br><span class="line">      Serial.println(<span class="string">&quot;Response: &quot;</span> + response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Serial.println(<span class="string">&quot;Error on sending POST: &quot;</span> + String(httpResponseCode));</span><br><span class="line">    &#125;</span><br><span class="line">    http.end(); <span class="comment">// 关闭连接</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Serial.println(<span class="string">&quot;Wi-Fi not connected&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  delay(<span class="number">5000</span>); <span class="comment">// 每 5 秒发送一次数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HTTP就是那么的神奇</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近的日子在想着达到就业的水平，不断地提升额，嗯然后今天手机掉水里了，烘干24小时，看看能不能复活吧，突然觉得之前手机不是那么重要，回想起它占用&lt;br&gt;我的时间，好像都不是什么重要的事情，近期来，感觉是为了让自己舒服一点，白天学完，晚上回去就刷手机而且就是 12点 1点，恶</summary>
      
    
    
    
    <category term="生活" scheme="https://whuichenggong.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>分布式系统学习</title>
    <link href="https://whuichenggong.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Distributed/"/>
    <id>https://whuichenggong.github.io/2024/12/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/Distributed/</id>
    <published>2024-12-09T12:53:55.062Z</published>
    <updated>2025-05-11T07:15:29.909Z</updated>
    
    <content type="html"><![CDATA[<p><code>go build -buildmode=plugin ../mrapps/wc.go</code><br>这个指令是什么意思 :</p><p>这个命令的作用是编译 ..&#x2F;mrapps&#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的插件文件通常是一个 .so（共享库文件）文件，它可以在运行时被其他 Go 程序通过 plugin 包加载和调用。</p><p>例如：</p><p>你可以在主程序中使用 plugin 包动态加载 wc.so 插件，并调用插件中的函数。</p><p><code>go run mrsequential.go wc.so pg*.txt：</code></p><p>go run：用于编译并运行 Go 程序。它会在内存中临时编译指定的 Go 文件，并立即执行。</p><p>mrsequential.go：这是要执行的 Go 源文件，Go 编译器会先编译这个文件并运行它。这个文件应该包含 main 函数，通常是程序的入口点。</p><p>wc.so：这是一个 Go 插件文件（共享库）。它通常是通过 go build -buildmode&#x3D;plugin 命令生成的。该文件包含 Go 代码，可能定义了一个插件接口，在运行时可以被主程序（mrsequential.go）动态加载和调用。wc.so 可能提供某些功能，mrsequential.go 将加载并使用这些功能。</p><p>pg*.txt：这是一个通配符表达式，表示所有以 pg 开头，后面跟任意字符，且以 .txt 结尾的文件。例如，pg1.txt, pg42.txt, pgfile.txt 都会被匹配并作为参数传递给程序。</p><p><code>more mr-out-0</code> 将会输出很多文本 这是因为：</p><p>mrsequential.go 将其输出保留在文件 mr-out-0 中。输入来自名为 pg-xxx.txt 的文本文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;go build -buildmode=plugin ../mrapps/wc.go&lt;/code&gt;&lt;br&gt;这个指令是什么意思 :&lt;/p&gt;
&lt;p&gt;这个命令的作用是编译 ..&amp;#x2F;mrapps&amp;#x2F;wc.go 文件，并将其生成一个 Go 插件文件。生成的</summary>
      
    
    
    
    <category term="计算机系统" scheme="https://whuichenggong.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
  </entry>
  
</feed>
